/*
Navicat MySQL Data Transfer

Source Server         : TEST
Source Server Version : 50727
Source Host           : 134.175.187.181:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50727
File Encoding         : 65001

Date: 2020-08-31 10:19:27
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for admin
-- ----------------------------
DROP TABLE IF EXISTS `admin`;
CREATE TABLE `admin` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `email` varchar(128) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `password` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  `deleted_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of admin
-- ----------------------------
INSERT INTO `admin` VALUES ('1', '梁凤波', 'itbo@163.com', '$2a$10$nnLARaiVcQAKTfALLnehYOLLU33/W7sSURmB5Buk3FjFuumHwBXei', '2019-06-17 15:14:47', '2019-06-17 15:14:47', null);
INSERT INTO `admin` VALUES ('2', '哈哈哈', '786039294@qq.com', '$2a$10$SHHNXa5eL9LG5JlOqZIkY.LPebmkunackuz1TTM672mM099DLeH/S', '2019-10-30 18:52:17', '2019-10-30 18:52:17', null);

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `author` varchar(64) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `content` text COLLATE utf8mb4_unicode_ci,
  `cover` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `category_id` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `browse` int(11) DEFAULT '0',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  `deleted_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', '今夜一起学习Node.js吗？?32324', '梁凤波', '## 原型链\n### 构造函数、原型和实例对象的关系\n\n每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例对象都包含一个指向原型对象的内部指针`[[Prototype]]`，也称为\\_\\_proto__。\n\n### 原型链的概念\n\n每个实例对象都有一个指向创建它的构造函数的原型对象的内部指针`[[Prototype]]`，这个内部指针可以叫做`__proto__`，而它的构造函数的原型对象可能也有一个指向创建它的构造函数的原型对象的内部指针`__proto__`，这些层层的关系，就形成一个原型链。\n\n### 原型链的作用\n\n当试图访问一个对象的属性时，它不仅仅在该对象上进行查询，还会继续查询该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。\n\n### 原型链继承\nECMAScript 实现继承主要依靠原型链来继承的，原型链继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n原型链继承的实现代码：\n\n```js\n// 父类\nfunction Parent() {\n    this.name = \'Parent\';\n}\n\nParent.prototype.getName = function () {\n    return this.name + \' Function\';\n}\n\n// 子类\nfunction Child() {\n    this.jobs = \'CodingMonkey\';\n}\n\n// 继承 Parent 父类\nChild.prototype = new Parent();\n\nChild.prototype.getJobs = function () {\n    return this.jobs + \' Function\'\n}\n\n// 实例化子类\nvar child = new Child();\n\nconsole.log(child.jobs); // \'CodingMonkey\' -- 来自子类的属性\nconsole.log(child.name); // \'Parent\' -- 来自父类的属性\nconsole.log(child.getName()); // \'Parent Function\' -- 来自父类的方法\nconsole.log(child.getJobs()); // \'CodingMonkey Function\' -- 来自子类的方法\n\n// 实现原理\nconsole.log(child.__proto__ === Child.prototype); // true\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\nconsole.log(Parent.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n<img width=\"750\" alt=\"原型链\" src=\"https://user-images.githubusercontent.com/26264225/58805995-c8224580-8647-11e9-8c49-7f847b7f187e.png\">\n\n\n如图示，实例对象 child 能访问到 Parent 原型上的方法，因为在 Child.prototype 指向了 Parent.prototype，因此拥有了 Parent 的属性和原型上的方法。\n\n上面的图例也证明了原型的搜索机制：当以读取访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上，上面的步骤就是：搜索实例 => 搜索`Child.prototype` => 搜索`Parent.prototype` => 最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。\n\n## 确定原型和实例的关系\n### instanceof\ninstanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\n```js\nconsole.log(child instanceof Child); // true\nconsole.log(child instanceof Parent); // true\nconsole.log(child instanceof Object); // true\n```\n\n### isPrototype()\nisPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。\n```js\nconsole.log(Child.prototype.isPrototypeOf(child)); // true\nconsole.log(Parent.prototype.isPrototypeOf(child)); // true\nconsole.log(Object.prototype.isPrototypeOf(child)); // true\n```\n\n## 重写原型链\n\n1. 如果子类想覆盖父类的某个方法，或者重写父类的某个方法，在通过原型链实现继承后面写即可。\n```js\n// 父类\nfunction Parent() {\n    this.name = \'Parent\';\n}\n\nParent.prototype.getName = function () {\n    return \'parent\';\n}\n\n// 子类\nfunction Child() {\n    this.jobs = \'CodingMonkey\';\n}\n\n// 继承 Parent 父类\nChild.prototype = new Parent();\n\nChild.prototype.getJobs = function () {\n    return this.jobs;\n}\n\n// 会重写 Parent 父类的 getName 方法\nChild.prototype.getName = function () {\n    return \'child\';\n}\n```\n\n2. 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。\n\n```js\n// 父类\nfunction Parent() {\n    this.name = \'Parent\';\n}\n\nParent.prototype.getName = function () {\n    return this.name + \' Function\';\n}\n\n// 子类\nfunction Child() {\n    this.jobs = \'CodingMonkey\';\n}\n\n// 继承 Parent 父类\nChild.prototype = new Parent();\n//使用字面量添加新方法，会导致上一行代码 继承 Parent 父类无效\nChild.prototype = {\n    getName: function () {\n        return \'child2\';\n    }\n}\n```\n\n## 课后练习\n- [ ] 什么是原型链？\n- [ ] 原型链有什么作用？\n- [ ] 原型链的搜索机制\n- [ ] 如何确定原型和实例的关系\n- [ ] instanceof 判断原理\n\n\n\n## 参考资料\n- [《JavaScript高级程序设计（第3版）》](http://www.ituring.com.cn/book/946), by Nicholas C.Zakas (作者) 李松峰 , 曹力 (译者)\n', 'http://cdn.boblog.com/Fs2YXZPDWOHRQgu_mChn4-YE0Bf9', '1', '151', '2019-06-17 15:16:05', '2019-10-30 18:52:34', '2019-10-30 18:52:34');
INSERT INTO `article` VALUES ('2', '深入理解原型链', '梁凤波', '## 原型链\n### 构造函数、原型和实例对象的关系\n\n每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例对象都包含一个指向原型对象的内部指针`[[Prototype]]`，也称为\\_\\_proto__。\n\n### 原型链的概念\n\n每个实例对象都有一个指向创建它的构造函数的原型对象的内部指针`[[Prototype]]`，这个内部指针可以叫做`__proto__`，而它的构造函数的原型对象可能也有一个指向创建它的构造函数的原型对象的内部指针`__proto__`，这些层层的关系，就形成一个原型链。\n\n### 原型链的作用\n\n当试图访问一个对象的属性时，它不仅仅在该对象上进行查询，还会继续查询该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。\n\n### 原型链继承\nECMAScript 实现继承主要依靠原型链来继承的，原型链继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n原型链继承的实现代码：\n\n```js\n// 父类\nfunction Parent() {\n    this.name = \'Parent\';\n}\n\nParent.prototype.getName = function () {\n    return this.name + \' Function\';\n}\n\n// 子类\nfunction Child() {\n    this.jobs = \'CodingMonkey\';\n}\n\n// 继承 Parent 父类\nChild.prototype = new Parent();\n\nChild.prototype.getJobs = function () {\n    return this.jobs + \' Function\'\n}\n\n// 实例化子类\nvar child = new Child();\n\nconsole.log(child.jobs); // \'CodingMonkey\' -- 来自子类的属性\nconsole.log(child.name); // \'Parent\' -- 来自父类的属性\nconsole.log(child.getName()); // \'Parent Function\' -- 来自父类的方法\nconsole.log(child.getJobs()); // \'CodingMonkey Function\' -- 来自子类的方法\n\n// 实现原理\nconsole.log(child.__proto__ === Child.prototype); // true\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\nconsole.log(Parent.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n<img width=\"750\" alt=\"原型链\" src=\"https://user-images.githubusercontent.com/26264225/58805995-c8224580-8647-11e9-8c49-7f847b7f187e.png\">\n\n\n如图示，实例对象 child 能访问到 Parent 原型上的方法，因为在 Child.prototype 指向了 Parent.prototype，因此拥有了 Parent 的属性和原型上的方法。\n\n上面的图例也证明了原型的搜索机制：当以读取访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上，上面的步骤就是：搜索实例 => 搜索`Child.prototype` => 搜索`Parent.prototype` => 最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。\n\n## 确定原型和实例的关系\n### instanceof\ninstanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\n```js\nconsole.log(child instanceof Child); // true\nconsole.log(child instanceof Parent); // true\nconsole.log(child instanceof Object); // true\n```\n\n### isPrototype()\nisPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。\n```js\nconsole.log(Child.prototype.isPrototypeOf(child)); // true\nconsole.log(Parent.prototype.isPrototypeOf(child)); // true\nconsole.log(Object.prototype.isPrototypeOf(child)); // true\n```\n\n## 重写原型链\n\n1. 如果子类想覆盖父类的某个方法，或者重写父类的某个方法，在通过原型链实现继承后面写即可。\n```js\n// 父类\nfunction Parent() {\n    this.name = \'Parent\';\n}\n\nParent.prototype.getName = function () {\n    return \'parent\';\n}\n\n// 子类\nfunction Child() {\n    this.jobs = \'CodingMonkey\';\n}\n\n// 继承 Parent 父类\nChild.prototype = new Parent();\n\nChild.prototype.getJobs = function () {\n    return this.jobs;\n}\n\n// 会重写 Parent 父类的 getName 方法\nChild.prototype.getName = function () {\n    return \'child\';\n}\n```\n\n2. 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。\n\n```js\n// 父类\nfunction Parent() {\n    this.name = \'Parent\';\n}\n\nParent.prototype.getName = function () {\n    return this.name + \' Function\';\n}\n\n// 子类\nfunction Child() {\n    this.jobs = \'CodingMonkey\';\n}\n\n// 继承 Parent 父类\nChild.prototype = new Parent();\n//使用字面量添加新方法，会导致上一行代码 继承 Parent 父类无效\nChild.prototype = {\n    getName: function () {\n        return \'child2\';\n    }\n}\n```\n\n## 课后练习\n- [ ] 什么是原型链？\n- [ ] 原型链有什么作用？\n- [ ] 原型链的搜索机制\n- [ ] 如何确定原型和实例的关系\n- [ ] instanceof 判断原理\n\n\n\n## 参考资料\n- [《JavaScript高级程序设计（第3版）》](http://www.ituring.com.cn/book/946), by Nicholas C.Zakas (作者) 李松峰 , 曹力 (译者)\n', 'http://cdn.boblog.com/FuyyakhdqFMQa8tli6lw7WH-rM0I', '1', '57', '2019-06-17 16:11:18', '2019-10-30 18:52:32', '2019-10-30 18:52:32');
INSERT INTO `article` VALUES ('3', '深入理解继承', 'asa', '1212', 'http://cdn.boblog.com/FrQyfc8vTmQQyntTJvMTnMmhcdt3', '1', '1', '2019-06-20 17:08:57', '2019-06-20 17:16:23', '2019-06-20 17:29:00');
INSERT INTO `article` VALUES ('4', '132123123', '3123123', '32121312321', 'http://qiniu.20151212.club/FlCTWDHBnzAJyPlj7zAuao9nfz0g', '1', '2', '2019-10-30 18:52:48', '2019-10-30 19:17:17', '2019-10-30 19:17:17');
INSERT INTO `article` VALUES ('5', '测试', '传', '呀呀呀呀', 'http://qiniu.20151212.club/FhiH1RdZqwVoyk_oVnMS5M8hOLMR', '2', '2', '2019-10-30 19:17:34', '2019-11-07 11:50:44', '2019-11-07 11:50:44');
INSERT INTO `article` VALUES ('6', '测试macdow', '旭旭', '## MDN中的解释  \nEvent 接口表示在 DOM 中发生的任何事件([常见事件][1]); 一些是用户生成的（例如鼠标或键盘事件），而其他由 API 生成（例如指示动画已经完成运行的事件，视频已被暂停等等）。事件通常由外部源触发，**同样也会以编程方式触发**，例如执行一个 element 的一个 HTMLElement.click( ) 方法，或**通过定义事件，然后使用 EventTarget.dispatchEvent( ) 将其派发到一个指定的目标**。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。\n\n## 注册事件监听器主要方式有：  \n### 1. 使用EventTarget.addEventListener \n~~~\nlet myButton=document.querySelector(\"#mybtn\");\nmyButton.addEventListener(\'click\', function(){\n    alert(\'Hello world\');\n}, false);\n~~~\n### 2. 使用HTML元素属性\n~~~\n<div onclick=\"alert(\'hello\')\"></div>\n~~~\n### 3. 使用DOM元素属性\n~~~\nlet myButton=document.querySelector(\"#mybtn\");\nmyButton.onclick=function(event){\n    alert(\'Hello world\');\n};\n~~~\n\n\n  [1]: https://developer.mozilla.org/zh-CN/docs/Web/Events', 'http://qiniu.20151212.club/FlCTWDHBnzAJyPlj7zAuao9nfz0g', '3', '5', '2019-10-30 19:22:33', '2019-11-07 11:50:42', '2019-11-07 11:50:42');
INSERT INTO `article` VALUES ('7', 'linux命令之用户', '旭旭', '## 查看用户\n**who 命令常用参数**\n|参数|说明|\n| --- | :---: |\n|-a	|打印能打印的全部|\n|-d	|打印死掉的进程|\n|-m	|同am i,mom likes 查看当前用户|\n|-q	|打印当前登录用户数及用户名|\n|-u	|打印当前登录用户登录信息|\n|-r	|打印运行等级|\n|whoami|打印当前切换的用户|\n**exit** 或者 **Ctrl+d** 退出当前用户\n## 创建用户\nsu <user> 可以切换到用户 user，执行时需要输入目标用户的密码，sudo <cmd> 可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。su - <user> 命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。\n**1. 切换用户**\n~~~\nsu <user>\nsu - <user>\n~~~\n**2.添加用户**\n~~~\nsudo adduser <user> \n~~~\n**3.更改用户密码**\n~~~\nsudo passwd <user>\n~~~\n## 用户组\n|命令|说明|\n| --- | --- |\n|groups <user>	|查看 <user> 的用户组，中冒号之前表示用户，后面表示该用户所属的用户组|\n|cat /etc/group	|/etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。|\n|sudo usermod -G sudo <user>|使用具有sudo权限的用户添加一个用户至sudo用户组，使其具有sudo权限|\n## 删除用户\n~~~\n$ sudo deluser <user> --remove-home\n~~~', 'http://qiniu.20151212.club/FjBXY2LnR_BTlyM7VluJr98QRIfZ', '4', '11', '2019-10-31 10:49:20', '2020-03-31 19:37:54', null);
INSERT INTO `article` VALUES ('8', 'linux命令之文件及权限', '旭旭', '## 查看文件\n|命令|说明|\n|-|-|\n|ls -l|使用较长格式列出文件|\n|ls -A|显示所有文件，包括隐藏文件|\n|ls -dl <目录名>|查看某一个目录的完整属性，而不是显示目录里面的文件属性|\n\n## 创建文件及变更\n|命令|说明|\n|-|-|\n|touch <fileName>|在当前文件夹下创建一个文件|\n|touch <fileName>|在当前文件夹下创建一个文件|\n\n', 'http://qiniu.20151212.club/FjBXY2LnR_BTlyM7VluJr98QRIfZ', '4', '31', '2019-10-31 11:17:18', '2020-06-24 18:19:36', null);
INSERT INTO `article` VALUES ('9', 'npm 脚本', '旭旭', '## 什么是npm 脚本\nnpm 允许在package.json文件里面，使用scripts字段定义脚本命令。\n~~~\n{ \n  // ...\n  \"scripts\":{\n    \"build\":\"node build.js\"\n   }\n}\n~~~\n\n上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。\n~~~\nnpm run build //等同于执行node build.js\n~~~\n这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。\n1. 项目的相关脚本，可以集中在一个地方。\n2. 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。\n3. 可以利用 npm 提供的很多辅助功能。\n\n查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。\n~~~\nnpm run\n~~~\n## 原理\nnpm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。\n比较特别的是，**npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样**。这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。\n比如，当前项目的依赖里面有webpack-dev-server，只要直接写webpack-dev-server就可以了。\n~~~\n\"scripts\": {\n    \"dev\": \"webpack-dev-server\"\n  }\n~~~\n由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。\n## 通配符\n由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。\n~~~\n\"lint\":\"jshint *.js\",\n\"lint\":\"jshint **/*.js\"\n~~~\n上面代码中，*表示任意文件名，**表示任意一层子目录。\n\n如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。\n~~~\n\"test\":\"tap test/\\*.js\"\n~~~\n## 传参\n向 npm 脚本传入参数，要使用--标明。\n~~~\n\"lint\":\"jshint **.js\"\n~~~\n向上面的npm run lint命令传入参数，必须写成下面这样。\n~~~\n$ npm run lint --reporter checkstyle>checkstyle.xml\n~~~\n也可以在package.json里面再封装一个命令。\n~~~\n\"lint:checkstyle\":\"npm run lint --reporter checkstyle > checkstyle.xml\"\n~~~\n## 执行顺序\n如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。\n\n如果是并行执行（即同时的平行执行），可以使用&符号。\n~~~\n$ npm run script1.js&npm run script2.js\n~~~\n如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。\n~~~\n$ npm run script1.js&&npm run script2.js\n~~~\n\n这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。等\n## 默认值\n一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。\n~~~\n\"start\":\"node server.js\"，\n\"install\":\"node-gyp rebuild\"\n~~~\n上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。\n## 钩子\nnpm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。\n~~~\n\"prebuild\":\"echo I run before the build script\",\n\"build\":\"cross-env NODE_ENV=production webpack\",\n\"postbuild\":\"echo I run after the build script\"\n~~~\n用户执行npm run build的时候，会自动按照下面的顺序执行。\n~~~\nnpm run prebuild && npm run build && npm run postbuild\n~~~\n因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。\n~~~\n\"clean\":\"rimraf ./dist && mkdir dist\",\n\"prebuild\":\"npm run clean\",\n\"build\":\"cross-env NODE_ENV=production webpack\"\n~~~\nnpm 默认提供下面这些钩子。\n~~~\nprepublish，postpublish\n\npreinstall，postinstall\n\npreuninstall，postuninstall\n\npreversion，postversion\n\npretest，posttest\n\nprestop，poststop\n\nprestart，poststart\n\nprerestart，postrestart\n~~~\n\n自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。\n\nnpm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。\n~~~\nconst TARGET=process.env.npm_lifecycle_event;\nif(TARGET===\'test\'){\n  console.log(`Running the test task!`);\n}\nif(TARGET===\'pretest\'){\n console.log(`Running the pretest task!`);\n}\nif(TARGET===\'posttest\'){\n console.log(`Running the posttest task!`);\n}\n~~~\n注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。\n## 变量\nnpm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过**npm_package_**前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。\n~~~\n{\n \"name\":\"foo\",\n \"version\":\"1.2.5\",\n \"scripts\":{\n  \"view\":\"node view.js\"\n }\n}\n~~~\n那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。\n~~~\n// console.log(process.env.npm_package_name); \n// console.log(process.env.npm_package_version); \n~~~\n上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。\nnpm_package_前缀也支持嵌套的package.json字段。\n~~~\n\"repository\":{\n  \"type\":\"git\",\n  \"url\":\"xxx\"\n},\nscripts:{\n  \"view\":\"echo $npm_package_repository_type\"\n}\n~~~\n上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。\n\n下面是另外一个例子。\n~~~\n\"scripts\":{\n  \"install\":\"foo.js\"\n}\n~~~\n上面代码中，npm_package_scripts_install变量的值等于foo.js。\n\n然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。\n~~~\n\"view\":\"echo $npm_config_tag\",\n~~~\n注意，**package.json里面的config对象，可以被环境变量覆盖。**\n~~~\n{\n \"name\":\"foo\",\n \"config\":{\n  \"port\":\"8080\"\n },\n \"scripts\":{\n  \"start\":\"node server.js\"\n }\n}\n~~~\n上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。\n~~~\nnpm configsetfoo:port 80\n~~~\n最后，env命令可以列出所有环境变量。\n~~~\n\"env\":\"env\"\n~~~', 'http://qiniu.20151212.club/For7cq9FD6sd10uMfPY8FmzIjVBq', '5', '8', '2019-11-04 19:18:04', '2019-12-21 16:46:19', null);
INSERT INTO `article` VALUES ('10', 'js 原型', '旭旭', '## 普通对象与函数对象\n> 所有 **Function** 的实例都是**函数对象**，而其他的都是**普通对象**。\n例如：\n~~~\nfunction a(){}\n// 此时 a 就是一个函数对象 或者更直观如下\n\nconst sum = new Function(\'a\', \'b\', \'return a + b\');\nsum.__proto__===Function.prototype  // true\na.__proto__===Function.prototype  // true\nsum instanceof Function // true\n\n// js**内置对象本身**都是函数对象\n\nObject.__proto__===Function.prototype //true\nArray.__proto__===Function.prototype //true\nString.__proto__===Function.prototype //true\n...\nObject instanceof Function\nArray instanceof Function\nString instanceof Function\n...\n~~~\n有趣的是 Function对象自身也是Function的实例\n~~~\nFunction.__proto__===Function.prototype // true\nFunction instanceof Function //true\n~~~\n## 总结\n![image.png](http://qiniu.20151212.club/FiOpdeV2sfiFtIzh_ubMEniVF01T)\n>1. 函数对象的 __proto__ 指向 Function.prototype；\n>2. instance(实例).__proto__ 指向 函数对象的 prototype；\n>3. 普通对象的 __proto__ 指向 Object.prototype；\n>4. 普通对象没有 prototype 属性；\n>5. 在访问一个对象的某个属性/方法时，若在当前对象上找不到，则会尝试访问 ob.__proto__, 也就是访问该对象的构造函数的原型 obCtr.prototype，若仍找不到，会继续查找 obCtr.prototype.__proto__，像依次查找下去（最终到 null）。若在某一刻，找到了该属性，则会立刻返回值并停止对原型链的搜索，若找不到，则返回 undefined。**(原型链)**\n\n**内置函数对象 (类/函数)** 本身的 __proto__ 都指向 Function 的原型对象；\n除了 Object 的原型对象的 __proto__ 指向 null，其他所有内置函数对象的原型对象的 __proto__ 都指向 object。', 'http://qiniu.20151212.club/FgtJ_BXXhTkgQ4VvhjJWWlJ64gJQ', '6', '45', '2019-11-07 11:50:32', '2020-08-25 15:06:18', null);
INSERT INTO `article` VALUES ('11', '阅读正则', '旭旭', '::: hljs-center\r\n\r\n![timg 1.jfif](http://qiniu.20151212.club/Frv1IXqXorIPMDGNkrDp13-oUz8k)\r\n\r\n![5912921396398be368b5f48ef80df332.jpg](http://qiniu.20151212.club/FmnYYEYGSEe4gFinLIS1xJZqKBGj)\r\n![dc1f9a0a170a4ad0b830f0b9c5d07afe_th.jpg](http://qiniu.20151212.club/Fv89QmoZqKfx1q4bkErmnQTiEI1D)\r\n![36_112_59_17020191122121225_43118.gif](http://qiniu.20151212.club/FtBQbgBV-kDQBNKzTl4i7koOJ6v6)\r\n# /(?=.\\*\\d)(?=.\\*[A-Z])(?=.\\*\\W)(?=.\\*[a-z])(?=.\\*\\S)\\^[0-9A-Za-z\\S]{6,12}$/g\r\n![image 1.png](http://qiniu.20151212.club/Fi2zU54mNM67KTwDubz6EqRbGJeH)\r\n\r\n:::  \r\n\r\n> 个人理解：正则的基础匹配如同坐标轴一样，有横向匹配，纵向匹配，位置匹配；\r\n\r\n## 量词 (横向)\r\n![量词横向.png](http://qiniu.20151212.club/FlVCPnEKGp1FWznqZgEVfrTU9GGn)\r\n|字符	|匹配|\r\n|-|-|-|\r\n|{n,m} |匹配至少n次，但不能超过m次|\r\n|{n,}	|匹配n次或者更多次|\r\n|{n}	|匹配n次|\r\n|?	|匹配0或者1次，等价于{0,1}|\r\n|+	|匹配1次或者多次，等价于{1,}|\r\n|*	|匹配0次或者多次，等价于{0,}|\r\n>**惰性量词：？**\r\n~~~\r\n/a+/ //mach\r\n~~~\r\n> **匹配模式 g (global)**\r\n~~~\r\n/a/ //mach\r\n/a/g\r\n~~~\r\n\r\n## 字符组(纵向) \r\n![字符组纵向.png](http://qiniu.20151212.club/FuywoPjtsg3Xi4_Pn_mjb-fqp1HU)\r\n|字符	|匹配|\r\n|-|-|-|\r\n|[abcdefg...]	|匹配abcdefg...的任意一个|\r\n|[a-z]	|匹配a到z直接的任意一个|\r\n|.	|除换行符和其他Unicode行终止符之外的任意单个字符|\r\n|\\w	|等价于[a-zA-Z0-9]|\r\n|\\W	|等价于[^a-zA-Z0-9] 特殊字符|\r\n|\\s	|任何空白符|\r\n|\\S	|任何非空白符的字符|\r\n|\\d	|阿拉伯数字0-9|\r\n|\\D	|非阿拉伯数字|\r\n**基础字符**\r\n|字符|匹配|\r\n|-|-|-|\r\n|字母和数字字符|	自身|\r\n|\\t|	制表符|\r\n|\\n|	换行符|\r\n|\\v|	纵向空白符|\r\n|\\f|	换页符|\r\n|\\r|	回车符|\r\n|\\0|	空字符|\r\n|[\\b]	|退格符|\r\n|\\ |匹配时按文本形式来识别其后的任何元字符或/分隔符（转义字符）|\r\n\r\n## 分支 (选择和分组)\r\n![分支选择.png](http://qiniu.20151212.club/FsnuDFNbgEylRcbd3LMUu7J6R5kW)\r\n**1. 选择 \"|\"**\r\n> 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。\r\n具体形式如下：**(p1|p2|p3)**，其中 **p1、p2 和 p3** 是子模式，用 **|**（**管道符**）分隔，表示其中任何之一。需要注意的是，选择项的匹配次序是**从左到右**，直到发现了匹配项。如果左边的选项匹配，那么就会忽略右边的匹配项。跟js的短路运算(||) 是一样的。因此，当/ a|ab / 匹配“ab”时，只会匹配第一个字符。\r\n~~~\r\n/ab|cd/ 既可以匹配ab也可以匹配cd\r\n~~~\r\n\r\n**2. 分组 \"( )\"**\r\n![分组.png](http://qiniu.20151212.club/Fq6knjI5KdXdrwVN66OuLB_Nu-Eg)\r\n>  把**单独的项组合成独立的子表达式**，以便可以像处理一个独立的单元那样用 \"|\"、\"*\"、\"+\" 或者 \"?\" 来对单元内的项进行处理。例如：\r\n~~~\r\n/(ab)+(cd){1}/ 可以匹配\'ab\'多次加上一次cd\r\n~~~\r\n## 锚点 (位置) \r\n![锚点位置.png](http://qiniu.20151212.club/FgT2pQd9RAVLRK_r1GkhwHoV_dql)\r\n> 如何匹配确定数量的字符 ？如：匹配一个a\r\n~~~\r\n/a/.test(\"aaaaaaaaaaaaaaaaaaa\")\r\n~~~\r\n> 使用**锚点**将匹配字符串的特定位置。其中最常用的是使用 \'^\' 匹配字符串的开始，使用 \'$\' 匹配字符串的结束。\r\n**任意正则表达式**都可以作为锚点条件。\r\n> \"(?=p)\" p在这里表示一个子模式 叫正向先行断言，用以指定此位置接下来的字符与p匹配\r\n~~~\r\n直观的感受位置：\r\nvar result = \"hello\".replace(/(?=l)/g, \'--------\');\r\nconsole.log(result); ^ 这个 $ 同理\r\n~~~\r\n个人理解 (?=p) 就是匹配符合 p 模式的字符前面的那个位置\r\n> \"(?!p)\" 叫是负向先行断言，用以指定此位置接下来的字符都不匹配p。\r\n~~~\r\nvar result = \"hello\".replace(/(?!l)/g, \'--------\');\r\nconsole.log(result);\r\n~~~\r\n\r\n>位置应用例子：\r\n~~~\r\n// 数字千位分隔符\r\n\"12345678\" => \"12,345,678\"\r\n// 6到12位同时包含特殊字符，大小写字母和数字且不包含空白符\r\n// \\W 特殊字符\r\n// \\S 任何非空白符的字符\r\n// 匹配 _\r\n~~~\r\n## 注意点\r\n**量词连缀问题**\r\n> 匹配字符串a;且长度是3的倍数\r\n~~~\r\n/^a{3}+$/\r\n~~~\r\n**字符组连缀问题**\r\n~~~\r\n/[a]\\d/\r\n~~~\r\n## 进阶 \r\n1. 回溯法原理 贪婪匹配 惰性匹配\r\n2. 平衡法则\r\n3. 准确性 效率', 'http://qiniu.20151212.club/FgtJ_BXXhTkgQ4VvhjJWWlJ64gJQ', '6', '122', '2019-11-19 18:47:26', '2020-08-28 15:59:17', null);
INSERT INTO `article` VALUES ('12', '测试MD上传图片', '旭旭', '![u=491865045,1211705331fm=26gp=0.jpg](http://qiniu.20151212.club/For7cq9FD6sd10uMfPY8FmzIjVBq)\n![分支选择.png](1)![量词横向.png](2)![锚点位置.png](3)![字符组纵向.png](4)', 'http://qiniu.20151212.club/For7cq9FD6sd10uMfPY8FmzIjVBq', '4', '3', '2019-11-20 12:10:19', '2019-11-20 14:11:52', '2019-11-20 14:11:52');
INSERT INTO `article` VALUES ('13', '1', '1', '![字符组纵向.png](http://qiniu.20151212.club/FuywoPjtsg3Xi4_Pn_mjb-fqp1HU)', 'http://qiniu.20151212.club/FsnuDFNbgEylRcbd3LMUu7J6R5kW', '4', '3', '2019-11-20 12:25:27', '2019-11-20 14:11:48', '2019-11-20 14:11:48');
INSERT INTO `article` VALUES ('14', '2', '2', '![分支选择.png](http://qiniu.20151212.club/FsnuDFNbgEylRcbd3LMUu7J6R5kW)![量词横向.png](http://qiniu.20151212.club/FlVCPnEKGp1FWznqZgEVfrTU9GGn)![锚点位置.png](http://qiniu.20151212.club/FgT2pQd9RAVLRK_r1GkhwHoV_dql)![字符组纵向.png](http://qiniu.20151212.club/FuywoPjtsg3Xi4_Pn_mjb-fqp1HU)', 'http://qiniu.20151212.club/FsnuDFNbgEylRcbd3LMUu7J6R5kW', '4', '1', '2019-11-20 12:28:09', '2019-11-20 14:11:46', '2019-11-20 14:11:46');
INSERT INTO `article` VALUES ('15', '为什么可以通过 Array.prototype.slice.call()可以把一个类数组对象转换为数组；', '旭旭', '\n通过V8实现slice的源码\n~~~\nfunction ArraySlice(start, end) { \n  CHECK_OBJECT_COERCIBLE(this, \"Array.prototype.slice\"); \n  var len = TO_UINT32(this.length); \n  var start_i = TO_INTEGER(start); \n  var end_i = len; \n\n  if (!IS_UNDEFINED(end)) end_i = TO_INTEGER(end);//如果没传入end，end=length，即slice第二个参数可选。 \n\n  if (start_i < 0) { \n    start_i += len;//参数1的A分支 处理负值，+= length。如：为-1，则start从倒数第一个开始，负值绝对值小于length \n    if (start_i < 0) start_i = 0;//参数1的A.a分支 若仍未负值，则等于0。 即处理负值绝对值大于length [1,2,3].slice(-4)。 \n  } else { \n    if (start_i > len) start_i = len;//参数1的B分支 参数大于length，则等于length，处理 [1,2,3].slice(5),返回[] \n  } \n\n  if (end_i < 0) { \n    end_i += len;//参数2的A分支 处理负值，+= length。如：为-1，则start从倒数第一个开始，负值绝对值小于length \n    if (end_i < 0) end_i = 0;//参数2的A.a分支 若仍未负值，则等于0。 即处理负值绝对值大于length [1,2,3].slice(1,-4)。 \n  } else { \n    if (end_i > len) end_i = len;//参数2的B分支 参数大于length，则等于length，处理 [1,2,3].slice(1,5) == [1,2,3].slice(1) == \n  } \n    //最终返回结果的值。可以看到这里会返回一个新的真正的数组（ps：slice的好基友splice是修改原数组的。） \n  var result = []; \n  // 处理分支1   如果经历了上面代码的层层检查设置，结束值小于开始值，那么直接返回空数组，处理 [1,2,3].slice(2,1) \n  if (end_i < start_i) return result; \n  // 处理分支2 如果是数组 && !%IsObserved(this) && 结束大于1000 && %EstimateNumberOfElements(this) < 结束值 ，那么使用方法SmartSlice来处理 \n  if (IS_ARRAY(this) && \n      !%IsObserved(this) && \n      (end_i > 1000) && \n      (%EstimateNumberOfElements(this) < end_i)) { \n    SmartSlice(this, start_i, end_i - start_i, len, result); \n  } else { \n    // 处理分支2 调用SimpleSlice 处理。 \n    SimpleSlice(this, start_i, end_i - start_i, len, result); \n  } \n  //设置length，似乎多余？还是v8中的数组[] 需指定length。  此处待探寻。。。 \n  result.length = end_i - start_i; \n\n  return result; \n} \n/**\n 4  * 源码：https://github.com/v8/v8/blob/master/src/array.js#L196-L221\n 5  * @param {Array} array 具体需要艹做的数组\n 6  * @param {Number} start_i 参数1，从何处开始\n 7  * @param {Number} del_count 需要取到的长度。 参数2 - 参数1，\n 8  * @param {Number} len 数组长度\n 9  * @param {Array} deleted_elements 对于slice来说，是选择的那部分数组，对于splice来说，是删除的那些数组。\n10  * @returns {undefined}  此处直接艹做 传入的reuslt，即可反馈到ArraySlice作用域的result，与真实的浏览器环境不一样！。\n11  */\n12 function SmartSlice(array, start_i, del_count, len, deleted_elements) {\n13   // Move deleted elements to a new array (the return value from splice).\n14   // 猜测？ 获取start_i + del_count的key。[1,2,3,4].slice(1,2) 返回 [1,2,3,4][1+2]索引3  ，而当tart_i + del_count大于length时候返回整个数组，如[1,2,3,4].slice(2,3) 即[1,2,3,4][5] 返回整个数组\n15   var indices = %GetArrayKeys(array, start_i + del_count);\n16   if (IS_NUMBER(indices)) {\n17     var limit = indices;\n18     for (var i = start_i; i < limit; ++i) {\n19       var current = array[i];\n20       if (!IS_UNDEFINED(current) || i in array) {\n21         deleted_elements[i - start_i] = current;\n22       }\n23     }\n24   } else {\n25     var length = indices.length;\n26     for (var k = 0; k < length; ++k) {\n27       var key = indices[k];\n28       if (!IS_UNDEFINED(key)) {\n29         if (key >= start_i) {\n30           var current = array[key];\n31           if (!IS_UNDEFINED(current) || key in array) {\n32             deleted_elements[key - start_i] = current;\n33           }\n34         }\n35       }\n36     }\n37   }\n38 }\n39 \n40 \n41 // This is part of the old simple-minded splice.  We are using it either\n42 // because the receiver is not an array (so we have no choice) or because we\n43 // know we are not deleting or moving a lot of elements.\n44 /**\n45  * 源码：https://github.com/v8/v8/blob/master/src/array.js#L271-L282\n46  * @param {Array} array 具体需要艹做的数组\n47  * @param {Number} start_i 参数1，从何处开始\n48  * @param {Number} del_count 需要取到的长度。 参数2 - 参数1，\n49  * @param {Number} len 数组长度\n50  * @param {Array} deleted_elements 对于slice来说，是选择的那部分数组，对于splice来说，是删除的那些数组。\n51  * @returns {undefined}  此处直接艹做 传入的reuslt，即可反馈到ArraySlice作用域的result，与真实的浏览器环境不一样！。\n52  */\n53 function SimpleSlice(array, start_i, del_count, len, deleted_elements) {\n54   for (var i = 0; i < del_count; i++) {\n55     var index = start_i + i;\n56     // The spec could also be interpreted such that %HasLocalProperty\n57     // would be the appropriate test.  We follow KJS in consulting the\n58     // prototype.\n59     var current = array[index];\n60     if (!IS_UNDEFINED(current) || index in array) {\n61       deleted_elements[i] = current;\n62     }\n63   }\n64 }\n\n~~~\n我们可以看到，最终返回的 **result 其实是一个真正的数组（使用循环取值）**；所以这样就实现了类数组到数组的转化', 'http://qiniu.20151212.club/FlSDtDnS6BuXBxgpHdcuiUs1EoSd', '6', '19', '2019-11-25 16:55:47', '2020-06-24 19:43:46', null);
INSERT INTO `article` VALUES ('16', 'css 动画之 transform, transition, animation', '旭旭', '# transform\ntransform 属性向元素应用**2D或3D转换**。该属性允许我们对元素进行旋转、缩放、移动或倾斜\n\n![image.png](http://qiniu.20151212.club/FqdsHsMWxEjbAVzGEqy8lFOb9oHD)\n\n# transition\ntransition 属性是一个简写属性，用于设置四个过渡属性\n~~~\ntransition: property duration timing-function delay;\n~~~\n![image.png](http://qiniu.20151212.club/FkJssWzYsjeRI2h2QYLe1WOSMgck)\n# animation\nanimation 属性是一个简写属性，用于设置六个动画属性\n~~~\nanimation: name duration timing-function delay iteration-count direction;\n~~~\n![image.png](http://qiniu.20151212.club/Finnp9beAlazV75ou3rCdRSdG9MH)\n### @keyframes\n通过 @keyframes 规则,创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。在动画过程中,以百分比来规定改变发生的时间，或者通过关键词 \"from\" 和 \"to\"，等价于 0% 和 100%。0% 是动画的开始时间，100% 动画的结束时间。为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。\n**注：需要配合 animation 动画属性来实现动画效果**\n~~~\n@keyframes animationname {keyframes-selector {css-styles;}}\n~~~\n![image.png](http://qiniu.20151212.club/Fn6r2lEPlMud44WIp2WL75VpNX4B)', 'http://qiniu.20151212.club/FkWFEHcXIbZInxK-5lR2vdzHWMDl', '7', '12', '2020-02-13 11:00:51', '2020-08-19 18:21:37', null);
INSERT INTO `article` VALUES ('17', 'map 函数中使用异步函数时的执行顺序', '旭旭', '在map函数遍历中使用异步函数时，此时所有的异步函数是以并发形式执行的\n~~~\nvar asFn=function(){\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve(\"1111\")\n        },1000)\n    })\n}\nvar urls=[1,2,3,4]\nasync function login1(urls){\n    console.time();\n    for(let url of urls){\n        let res= await asFn();\n        console.log(res)\n    }\n    console.timeEnd();\n}\nasync function login2(urls){\n    console.time();\n    let arr = urls.map(async url=>{\n        let res= await asFn();\n        return res;\n    })\n    for (let a of arr){\n        console.log(await a)\n    }\n    console.timeEnd();\n}\nlogin1(urls)\n~~~', 'http://qiniu.20151212.club/FlSDtDnS6BuXBxgpHdcuiUs1EoSd', '6', '4', '2020-07-03 18:55:29', '2020-08-27 11:14:43', null);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `key` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `parent_id` int(11) DEFAULT '0',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  `deleted_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', 'nodejs', 'node', '0', '2019-06-17 15:15:54', '2019-10-30 19:16:11', '2019-10-30 19:16:11');
INSERT INTO `category` VALUES ('2', '测试分类1', '测试', '0', '2019-10-30 19:16:49', '2019-11-07 11:19:57', '2019-11-07 11:19:57');
INSERT INTO `category` VALUES ('3', '测试分类2', '测试2', '0', '2019-10-30 19:17:07', '2019-11-07 11:20:01', '2019-11-07 11:20:01');
INSERT INTO `category` VALUES ('4', 'linux', 'linux', '0', '2019-10-31 10:07:15', '2019-10-31 10:07:15', null);
INSERT INTO `category` VALUES ('5', 'node', 'node', '0', '2019-11-04 18:33:47', '2019-11-04 18:33:47', null);
INSERT INTO `category` VALUES ('6', 'js', 'js', '0', '2019-11-07 11:20:11', '2019-11-07 11:20:11', null);
INSERT INTO `category` VALUES ('7', 'css', 'css', '0', '2020-02-13 10:40:55', '2020-02-13 10:40:55', null);

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `email` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `content` text COLLATE utf8mb4_unicode_ci,
  `article_id` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `parent_id` int(11) DEFAULT '0',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  `deleted_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
-- Records of comments
-- ----------------------------
INSERT INTO `comments` VALUES ('1', '梁凤波', 'itbo@163.com', '评论1', '1', '0', '2019-06-17 15:16:45', '2019-10-30 19:15:45', '2019-10-30 19:15:45');
INSERT INTO `comments` VALUES ('2', '梁凤波2', '13@163.com', '评论2', '1', '1', '2019-06-17 15:18:50', '2019-10-30 19:15:48', '2019-10-30 19:15:48');
INSERT INTO `comments` VALUES ('3', '梁凤波3', '1212@163.com', '评论3', '1', '2', '2019-06-18 14:04:41', '2019-10-30 19:15:50', '2019-10-30 19:15:50');
INSERT INTO `comments` VALUES ('4', '梁凤波4', '121@14.com', '评论4', '1', '1', '2019-08-04 08:33:21', '2019-10-30 19:15:52', '2019-10-30 19:15:52');
INSERT INTO `comments` VALUES ('5', '梁凤波5', 'a@13.com', '评论5', '2', '0', '2019-08-04 09:48:37', '2019-10-30 19:15:36', '2019-10-30 19:15:36');
INSERT INTO `comments` VALUES ('6', '梁凤波6', 'sas@13.com', '评论5', '2', '5', '2019-08-04 09:49:41', '2019-10-30 19:15:34', '2019-10-30 19:15:34');
INSERT INTO `comments` VALUES ('7', '323123', null, '3123123', '8', '0', '2019-11-01 15:31:16', '2019-12-21 16:59:12', '2019-12-21 16:59:12');
INSERT INTO `comments` VALUES ('8', '323123', null, '**dawdawddd是大卫的舞多看见我的**', '8', '0', '2019-11-01 15:34:30', '2019-12-21 16:59:10', '2019-12-21 16:59:10');
INSERT INTO `comments` VALUES ('9', '23333', null, '23333333', '8', '0', '2019-11-01 16:27:17', '2019-12-21 16:59:09', '2019-12-21 16:59:09');
INSERT INTO `comments` VALUES ('10', '1', null, '## 二级标题', '6', '0', '2019-11-01 16:33:42', '2019-12-21 16:59:07', '2019-12-21 16:59:07');
INSERT INTO `comments` VALUES ('11', '321123', null, '2131231231231232', '8', '0', '2019-11-01 16:58:25', '2019-12-21 16:59:05', '2019-12-21 16:59:05');
INSERT INTO `comments` VALUES ('12', '11', null, '22', '11', '0', '2019-11-20 16:15:23', '2019-12-21 16:59:03', '2019-12-21 16:59:03');
